<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (POP)</TITLE>
<link rel="stylesheet" type="text/css" href="../../documentation/html/doc.css" />
<link href="../../documentation/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (POP)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../documentation/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../../documentation/index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id: model_mod.html 11612 2017-05-08 22:18:42Z nancy@ucar.edu $</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>The <strong>Parallel Ocean Program (POP)</strong> may be used with the 
   <strong>Data Assimilation Research Testbed (DART)</strong>.
   Both main variants - <a href="http://gcmd.nasa.gov/getserf.htm?LANL-POP">LANL POP</a> and
   <a href="http://www.cesm.ucar.edu/models/cesm1.0/pop2/">CESM1.0 POP2</a> have been 
   tested. We are assimilating salinity and temperature 
   observations from either the World Ocean Database (2005) or (2009).
   <br />
   <br />
   The following POP variables are extracted from the POP <strong>netCDF</strong> restart files and
   are conveyed to DART:
   <em class=code>SALT_CUR</em>,
   <em class=code>TEMP_CUR</em>,
   <em class=code>UVEL_CUR</em>,
   <em class=code>VVEL_CUR</em>, and 
   <em class=code>PSURF_CUR</em>. These variables are then adjusted to be consistent
   with real observations and stuffed back into the same netCDF restart files.
   Since DART is an ensemble algorithm, there are multiple restart files for a 
   single restart time: one for each ensemble member. Creating the initial ensemble
   of ocean states is an area of active research. At present, it may be sufficient
   to use a climatological ensemble; e.g., using the restarts for '1 January 00Z' 
   from 50 consecutive years. Experience has shown that having a paired (unique)
   atmospheric forcing maintains the ensemble spread better than simply forcing
   all the ocean ensemble members with one single atmospheric state.
   <br />
   <br />
   DART reads the grid information for POP from the files specified in 
   POP's <em class=code>&amp;grid_nml</em>.
   When DART is responsible for starting/stopping POP, the information is 
   conveyed through POP's <em class=code>&amp;time_manager_nml</em>. 
</P>

<div class=indent1>
   <h2><a href="http://www.cesm.ucar.edu/models/cesm1.0/pop2/">CESM1.0 POP2</a></h2>
   <P>
      was tested and run in production on NCAR's bluefire computer from IBM.
      This implementation is a significant departure from the DART 'business as usual' 
      model in that DART is not responsible for advancing the model - in this case,
      ALL of CESM! Instead, the CESM Interactive Ensemble facility is used to manage 
      the ensemble and the Flux Coupler is responsible for stopping POP at the times 
      required to perform an assimilation. DART simply runs 'end-to-end' at every
      assimilation time, while CESM runs continuously. This is a complete role-reversal
      from the normal DART operation but was relatively simple to implement because
      CESM had infrastructure to exploit. 
      <br />
      <br />
      Several modifications to CESM CASEROOT scripts will be required and will be 
      documented more later in this document.  The 
      <em class=file>DART/models/POP/shell_scripts/</em><em class=program>assimilate.csh</em>
      script is inserted into the CESM run script. The Flux Coupler stops POP every 
      midnight and all the observations within +/- 12 hours are assimilated.
      The observation sequence files have been parsed into 'daylong' chunks and
      have names derived from the date to facilitate manipulation in the UNIX shell.
      <br />
      <br />
      The DART components were built with the following settings:
   </P>
   <pre>
      MPIFC = mpxlf95_r
      MPILD = mpxlf95_r
      FC = xlf90_r
      LD = xlf90_r
      INCS = -I/usr/local/lib64/r4i4 -I/usr/local/include
      LIBS = -L/usr/local/lib64/r4i4 -lnetcdf
      FFLAGS = -qsuffix=f=f90:cpp=F90 -q64 -b64 -qarch=auto -qmaxmem=-1 -O2 $(INCS)
      LDFLAGS = $(FFLAGS) $(LIBS)
   </pre>
</div> 

<div class=indent1>
   <h2><a href="http://climate.lanl.gov/Models/POP/">LANL POP</a></h2>
   <h3>Has not been tested with this version of DART and must be verified.</h3>
   <P>
      is invoked the same way as any other high-order model.
      <b>Important</b>: This interface was tested with the LANL/POP 2_0_1 version 
      of POP ...  but STILL CANNOT BE USED for assimilation until the POP code is 
      modified to do a forward euler timestep for an 'assimilation' restart.
      <br />
      <br />
      DART is invoked and POP is started/stopped multiple times.
      It was checked in the gx3v5 geometry and POP was built in the 'default' 
      configuration: one which requires no forcing files, no boundary conditions, 
      etc., so I have no idea what to expect when confronting this with real
      observations ...
   </P>
   <pre>
      setenv ARCHDIR linux
      gmake OPTIMIZE=no COUPLED=no
   </pre>
   <P>
      Given the wide range of input files and modes for running POP - 
      the DART scripts will surely have to be modified to accomodate moving
      the boundary/forcing files required for different usage patterns.
      <br />
      <br />
      There are several scripts in the <em class=file>DART/models/POP/shell_scripts</em>
      directory that are employed when using DART to assimilate with a LANL/POP
      model: <em class=program>advance_model.csh</em>,
      <em class=program>run_perfect_model_obs.batch</em>, and
      <em class=program>run_filter.batch</em>&nbsp;. 
      <br />
      <br />
      The DART components compile and run on our Intel-based cluster running SLES10 
      with the ifort 10.1 20090203 compiler with the following flags 
      (the value of NETCDF was appropriate for our system):
   </P>
   <pre>
      MPIFC = mpif90
      MPILD = mpif90
      FC = ifort
      LD = ifort
      INCS = -I$(NETCDF)/include
      LIBS = -L$(NETCDF)/lib -lnetcdf -lmkl -lmkl_lapack -lguide -lpthread
      FFLAGS = -O0 -fpe0 -vec-report0 -assume byterecl $(INCS)
      LDFLAGS = $(FFLAGS) $(LIBS)
   </pre>
   <P>
      Intel-based machines are natively little-endian, so I like to append 
      a ".le" suffix on all binary files.
      <br />
      <br />
      On our machine, with the openmpi framework, it is necessary to specify 
      <em class=file>input.nml</em><em class=code>:&amp;mpi_utilities_nml:reverse_task_layout = .true.,</em>
      to be able to simultaneously run (2) MPI programs on the same set of nodes.
   </P>
</div> 

<div class=indent1>
   <h3>Observations.</h3>
   <P>
      The observations come from the 
      <a href="http://www.nodc.noaa.gov/OC5/WOD05/pr_wod05.html">World Ocean Database 2005</a>
      and are processed by DART routines in the
   <a href="../../observations/obs_converters/WOD/WOD.html">DART/observations/WOD</a> directory.  
   </P>
</div>

<a name="conversions"></a>
<div class=indent1>
   <h3>Converting between DART files and POP restart files.</h3>
   <P><strong>Is not needed.</strong>
      DART natively reads and writes netCDF files.
   </P>
</div>

<a name="InitialEnsemble"></a>
<div class=indent1>
   <h3>Generating the initial ensemble.</h3>
   <P>
      Creating the initial ensemble of ocean states is an area of active research.
      The POP model cannot take one single model state and generate its own 
      ensemble (typically done with <a href="#pert_model_copies">pert_model_copies</a>).
      <br />
      <br />
      The ensemble has to come from 'somewhere else'. 
      At present, it may be sufficient to use a climatological ensemble; e.g., 
      using the POP restarts for '1 January 00Z' from 50 consecutive years 
      from a hindcast experiment.
   </P>
      BTW - Experience has shown that having a paired (unique) atmospheric forcing 
      maintains the ensemble spread better than simply forcing all the ocean 
      ensemble members with one single atmospheric state.
   </P>
</div>

<a name="POP_OSSE"></a>
<div class=indent1>
   <h3>Generating a set of observations for a 'perfect model' experiment using the LANL/POP executable and scripts.</h3>
   <P>
      A perfectly sensible approach to get to know the system would be to try to 
   </P>
   <ol>
     <li>assimilate data for the first assimilation period and stop. Do not advance
         the model at all. The filter namelist can control all of this and you do
         not need to have a working <em class=program>advance_model.csh</em>
         script, or even a working ocean model (as long as you have input data files).</li>
     <li>advance the model first and then assimilate data for the first assimilation 
         period and stop.</li>
     <li>advance, assimilate and advance again. This tests the whole DART facility.</li>
   </ol>
   <P>
      I always like running something akin to a 'perfect model' experiment to start.
      Since I have not come up with a good way to perturb a single model state to
      generate an ensemble, here's the next best thing. The details for running 
      each program are covered in their own documentation.
   </P>
   <ol>
      <li>Create a set of initial conditions for DART by running one instance of POP 
         for a very long time and saving restart files 'every so often'.
         Use one of these as the initial condition
         for <em class=program>perfect_model_obs</em> and the rest as the
	 ensemble for the assimilation experiment. Since no one in their right 
	 mind would use a high-resolution model for a proof-of-concept case
	 (hint, hint), running a low-resolution model for a 'very long time' should
	 not be a problem.
      </li>

      <li>create a TINY (i.e. 1) set of 'perfect' observations in the normal fashion:
         <a href="../../assimilation_code/programs/create_obs_sequence/create_obs_sequence.html">create_obs_sequence</a>
         and then 
         <a href="../../assimilation_code/programs/create_fixed_network_seq/create_fixed_network_seq.html">create_fixed_network_seq</a>
         to create an empty observation sequence file 
         (usually called <em class=file>obs_seq.in</em>).
	 The programs will prompt you for all the information they require.
	 Read their documentation if necessary.
	 </li>

      <li>break the <em class=file>pop_in</em> namelist that comes with POP into
          two pieces - one called <em class=file>pop_in.part1</em>, 
	  that contains the <em class=code>&amp;time_manager_nml</em> and 
	  put the rest in <em class=file>pop_in.part2</em>. The 
	  <em class=code>&amp;time_manager_nml</em> will be repeatedly updated
	  as the POP model is repeatedly called by 
	  <em class=program>advance_model.csh</em>.
      </li>

      <li>modify <em class=file>POP/work/input.nml</em> as needed.
      </li>

      <li>modify 
         <em class=file>DART/models/POP/shell_scripts</em><em class=program>run_perfect_model_obs.batch</em> 
         to reflect the location of your DART directory, the POP directory, 
	 and which POPFILE to use as the initial condition.
      </li>

      <li>Run the experiment and populate the observation sequence file by
          executing/submitting the script 
	  <em class=file>DART/models/POP/shell_scripts/</em><em class=program>run_perfect_model_obs.batch</em>.
	  The script may require some modification, but not much. 
	  Please let me know if I can improve the readability or comments. 
	  <em class=program>run_perfect_model_obs.batch</em> runs 
	  <a href="../../assimilation_code/programs/perfect_model_obs/perfect_model_obs.html">perfect_model_obs</a>
      </li>

      <li><em class=program>run_filter.batch</em> runs 
          <a href="../../assimilation_code/programs/filter/filter.html">filter</a> in a similar fashion.
	  I have not finished the documentation for this yet.
      </li>
   </ol>
</div>


<a name="ExploringOutput"></a>
<div class=indent1>
   <h3>Exploring the Output.</h3>
   <P>
      Is pretty much like any other model. The netCDF files have the model 
      prognostic variables before and after the assimilation. 
      There are Matlab&#174; scripts for perusing the netCDF files in the 
      <em class=file>DART/matlab</em> directory. 
      There are Matlab&#174; scripts for exploring the performance of the 
      assimilation in observation-space (after running 
      <a href="../../assimilation_code/programs/obs_diag/threed_sphere/obs_diag.html">obs_diag</a> 
      to explore the <em class=file>obs_seq.final</em> file) - use the 
      scripts starting with 'plot_', i.e. 
      <em class=file>DART/diagnostics/matlab/plot_*.m</em>.
      As always, there are some model-specific item you should know about in 
      <em class=file>DART/models/POP/matlab</em>, and 
      <em class=file>DART/models/POP/shell_scripts</em>.
      <br />
      <br />
      It is also worthwhile to convert your obs_seq.final file to a netCDF format
      obs_sequence file with <a href="../../assimilation_code/programs/obs_seq_to_netcdf/obs_seq_to_netcdf.html">obs_seq_to_netcdf</a>
</P>
</div>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
Consider yourself forewarned that character strings that contain a '/' must be
enclosed in quotes to prevent them from prematurely terminating the namelist.
The variables and their default values are listed here:
</P>
<div class=namelist><pre>
&amp;model_nml
   assimilation_period_days     = -1
   assimilation_period_seconds  = -1
   model_perturbation_amplitude = 0.2
   binary_grid_file_format      = 'big_endian'
   debug                        = 0,
   model_state_variables        = 'SALT_CUR ', 'QTY_SALINITY             ', 'UPDATE',
                                  'TEMP_CUR ', 'QTY_POTENTIAL_TEMPERATURE', 'UPDATE',
                                  'UVEL_CUR ', 'QTY_U_CURRENT_COMPONENT  ', 'UPDATE',
                                  'VVEL_CUR ', 'QTY_V_CURRENT_COMPONENT  ', 'UPDATE',
                                  'PSURF_CUR', 'QTY_SEA_SURFACE_PRESSURE ', 'UPDATE'
  /
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>This namelist is read in a file called <em class=file>input.nml</em>.
   This namelist provides control over the assimilation period for the model.
   All observations within (+/-) half of the assimilation period are assimilated.
   The assimilation period is the minimum amount of time the model can be advanced,
   and checks are performed to ensure that the assimilation window is a multiple of
   the ocean model dynamical timestep.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>assimilation_period_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The number of days to advance the model for each assimilation.
                       If both <em class=code>assimilation_period_days</em> and 
                       <em class=code>assimilation_period_seconds</em> are&nbsp;&le;&nbsp;0; the value of
                       the POP namelist variables <em class=code>restart_freq</em> and
                       <em class=code>restart_freq_opt</em> are used to determine the 
                       assimilation period. WARNING: in the CESM framework, 
                       the <em class=code>restart_freq</em> is set to a value that is not 
                       useful so DART defaults to 1 day - even if you are using POP in 
                       the LANL framework. 
                       </TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>In addition to <em class=code>assimilation_period_days</em>, 
                       the number of seconds to advance the model for each assimilation.
                       Make sure you read the description of 
                       <em class=code>assimilation_period_days</em>
                       </TD></TR>

<TR><!--contents--><TD valign=top>model_perturbation_amplitude</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD valign=top> Reserved for future use.
                  <!-- The amount of noise to add when trying to perturb a single
                       state vector to create an ensemble. Only used when 
<em class=file>input.nml</em><em class=code>&amp;filter_nml:start_from_restart = .false.</em>
                       See also 
                       <a href="#InitialEnsemble">Generating the initial ensemble</a> 
                       at the start of this document. units: standard deviation 
                       of a gaussian distribution with the mean at the value of 
                       the state vector element. --> </TD></TR> 

<TR><!--contents--><TD valign=top>binary_grid_file_format</TD>
    <!--  type  --><TD valign=top>character(len=32)</em></TD>
    <!--descript--><TD valign=top>The POP grid files are in a binary format.
                       Valid values are 'native', 'big_endian', or 'little_endian'.
                       Modern versions of Fortran allow you to specify the endianness
                       of the file you wish to read when they are opened as opposed to
                       needing to set a compiler switch or environment variable. 
                       </TD></TR>

<TR><!--contents--><TD valign=top>debug</TD>
    <!--  type  --><TD valign=top>integer</em></TD>
    <!--descript--><TD valign=top>The switch to specify the run-time verbosity.
                       <em class=code>0</em> is as quiet as it gets.
                       <em class=code>&gt; 1</em> provides more run-time messages.
                       <em class=code>&gt; 5</em> provides ALL run-time messages.
                       All values above 0 will also write a netCDF file of the grid 
                       information and perform a grid interpolation test.</TD></TR>

<TR><!--contents--><TD valign=top>model_state_variables</TD>
    <!--  type  --><TD valign=top>character(:,3)</em></TD>
    <!--descript--><TD valign=top>Strings that associate POP variables with a DART kind 
                       and whether or not to write the updated values to the restart files.
                       These variables will be read from the POP restart file and modified 
                       by the assimilation. Some (perhaps all) will be used by the forward 
                       observation operators. If the 3rd column is 'UPDATE', the output 
                       files will have the modified (assimilated,posterior) values. 
                       If the 3rd column is 'NO_COPY_BACK', that variable will not be 
                       written to the restart files. <strong>The DART diagnostic files will
                       always have the (modified) posterior values.</strong> Diagnostic 
                       variables that are useful for the calculation of the forward 
                       observation operator but have no impact on the forecast trajectory 
                       of the model could have a value of 'NO_COPY_BACK'.
                       The DART kind must be one found in the 
                       <em class=file>DART/assimilation_code/modules/observations/obs_kind_mod.f90</em> AFTER it gets 
                       built by <em class=program>preprocess</em>. Most of the ocean 
                       observation kinds are specified by
                       <em class=file>DART/observations/forward_operators/obs_def_ocean_mod.f90</em>, 
                       so it should be specified in the
                       <em class=code>&amp;preprocess_nml:input_files</em> variable.
                       </TD></TR>
</TABLE>

</div>
<br />

<!--==================================================================-->

<A NAME="time_manager_nml"></A>
<br />
<div class=namelist><pre>
<em class=call>namelist /time_manager_nml/ </em> runid, stop_option, stop_count, &amp;
       time_mix_opt, fit_freq, time_mix_freq, dt_option, dt_count, impcor, laccel, &amp;
       accel_file, dtuxcel, allow_leapyear, date_separator, &amp;
       iyear0, imonth0, iday0, ihour0, iminute0, isecond0
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   This namelist is read in a file called <em class=file>pop_in</em>&nbsp;.
   This namelist is the same one that is used by the ocean model and is used 
   to control the integration length of POP. It is unimportant for the CESM/POP 
   experiments but is critically important for the LANL/POP experiments.
   The values are explained in full in the POP documentation. The DART code
   reads the namelist and simply overwrites several values with the new time
   integration information. All the other values are unchanged. 
   <br />
   <br />
   <em class=program>dart_to_pop</em> writes out a new 
   <em class=code>&amp;time_manager_nml</em> in <em class=file>pop_in.DART</em>
   if the DART state being converted has the 'advance_to_time' record in it.
   This is the case during the middle of a DART experiment, but is not 
   typically encountered if one is working with DART 'initial conditions' 
   or 'restart' files. The <em class=file>pop_in.DART</em> must be concatenated
   with the other namelists needed by POP into a file called 
   <em class=file>pop_in</em>&nbsp;. We have chosen to store the other 
   namelists (which contain static information) in a file called 
   <em class=file>pop_in.part2</em>. Initially, the 
   <em class=code>time_manager_nml</em> is stored in a companion file called 
   <em class=file>pop_in.part1</em> and the two files are concatenated into
   the expected <em class=file>pop_in</em> - then, during the course of an
   assimilation experiment, DART keeps writing out a new 
   <em class=code>time_manager_nml</em> with new integration information - 
   which gets appended with the static information in 
   <em class=file>pop_in.part2</em>&nbsp;
   <br />
   <br />
   If you are running the support programs in a standalone fashion 
   (as you might if you are converting restart files into an intial ensemble),
   the 'valid time' of the model state comes from the restart file 
   -&nbsp;NOT&nbsp;- the namelist. You can always patch the times in the 
   headers with <em class=program>restart_file_utility</em>.
   <br />
   <br />
   Only the namelist variables of interest to DART are discussed. All
   other namelist variables are ignored by DART - but mean something to POP.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>stop_option</TD>
    <!--  type  --><TD valign=top>character <em class=units>[default:&nbsp;'nday']</em></TD>
    <!--descript--><TD valign=top>The units for <em class=code>stop_count</em>.</TD></TR>

<TR><!--contents--><TD valign=top>stop_count</TD>
    <!--  type  --><TD valign=top>integer <em class=units>[default:&nbsp;1]</em></TD>
    <!--descript--><TD valign=top>The duration of the model integration. The units 
                                  come from <em class=code>stop_option</em>.</TD></TR>
</TABLE>

<H3 class=indent1>Example</H3>

<pre>
&amp;time_manager_nml
  runid          = 'gx3v5'
  stop_option    = <em class=input>'nday'</em>
  stop_count     = <em class=input>1</em>
  time_mix_opt   = 'avgfit'
  fit_freq       = 1
  time_mix_freq  = 17
  dt_option      = 'auto_dt'
  dt_count       = 1
  impcor         = .true.
  laccel         = .false.
  accel_file     = 'unknown_accel_file'
  dtuxcel        = 1.0
  allow_leapyear = .true.
  iyear0         = 2000
  imonth0        = 1
  iday0          = 1
  ihour0         = 0
  iminute0       = 0
  isecond0       = 0
  date_separator = '-'
   /
</pre>
</div>
<br />

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>

<PRE>
types_mod
time_manager_mod
threed_sphere/location_mod
utilities_mod
obs_kind_mod
mpi_utilities_mod
random_seq_mod
dart_pop_mod
</PRE>

<!--==================================================================-->
<!-- Note to authors. The first row of the table is different.        -->
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<P>
Only a select number of interfaces used are discussed here.
Each module has its own discussion of their routines. 
</P>

<h3 class=indent1>Required Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod,&nbsp;only&nbsp;:</em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_copies">pert_model_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#query_vert_localization_coord">query_vert_localization_coord</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_convert">vert_convert</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_model_time">read_model_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_model_time">write_model_time</A></TD></TR>
</TABLE>

<h3 class=indent1>Unique Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_gridsize">get_gridsize</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#restart_file_to_sv">restart_file_to_sv</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#sv_to_restart_file">sv_to_restart_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_pop_restart_filename">get_pop_restart_filename</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#test_interpolation">test_interpolation</A></TD></TR>
</TABLE>

<P>
Ocean model namelist interfaces <em class=code>&amp;PARM03</em>,
<em class=code>&amp;PARM04</em>, and 
<em class=code>&amp;PARM04</em> are read from 
file <em class=file>data</em>.
Ocean model namelist interface <em class=code>&amp;CAL_NML</em>,
is read from file <em class=file>data.cal</em>.
</P>

<TABLE>
<TR><TD><em class=call>use location_mod, only : </em></TD>
    <TD><A HREF="../../assimilation_code/location/threed_sphere/location_mod.html#get_close_obs">get_close_obs</A></TD></TR>
</TABLE>

<P>The presence of 'dry' gridpoints causes a little extra work for the
   <em class=program>get_close_obs()</em> routine. The routine normally
   comes from the <em class=program>location_mod</em> which has no notion
   of wet/dry grid cell attributes. As such, the POP 
   <em class=program>model_mod</em> will be augmenting the work done by
   <em class=program>location_mod/get_close_obs()</em>&nbsp;.
   <br />
   <br />
   Fundamentally, the <em class=program>location_mod</em> calculates and returns 
   all the 'close' observations.  DART is designed such that the routine that 
   uses the list of close observations is in <em class=file>model_mod.f90</em>. 
   Consequently, the POP <em class=program>model_mod</em> can take that 
   information and adjust as necessary. This creates some logistical issues 
   in that the POP model_mod needs to intercept all calls to 
   <em class=program>location_mod:get_close_obs()</em> - which can be achieved 
   with the following syntax:
</P>
<pre>
   use location_mod, only : loc_get_close_obs =&gt; get_close_obs
</pre>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--==================================================================-->
<H3 class=indent1>Required Interface Routines</H3>
<!--==================================================================-->

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br />
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
Required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br />
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>adv_1step</em>
is not used for the POP model.
Advancing the model is done through the <em class=program>advance_model</em> script.
This is a NULL_INTERFACE, provided only for compatibility with the DART requirements.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br />
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,&nbsp;var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_state_meta_data</em>
returns metadata about a given element of the DART representation of the 
model state vector. Since the DART model state vector is a 1D array and the
native model grid is multidimensional, <em class=code>get_state_meta_data</em>  
returns information about the native model state vector representation. Things
like the <em class=code>location</em>, or the type of the variable 
(for instance: salinity, temperature, u current component, ...). 
The integer values used to indicate different variable types in 
<em class=code>var_type</em> are themselves defined as public interfaces 
to model_mod if required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns the 3D location of the indexed state variable.
        The <em class=code>location_ type</em> comes from
        <em class=file>DART/location/threed_sphere/location_mod.f90</em>.
        Note that the lat/lon are specified in degrees by the user but are converted
        to radians internally.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.
        The type is one of the list of supported observation types, found in
        the block of code starting 
        <em class=code>!&nbsp;Integer&nbsp;definitions&nbsp;for&nbsp;DART&nbsp;TYPES</em>
        in <em class=file>DART/assimilation_code/modules/observations/obs_kind_mod.f90</em> 
        </TD></TR>

</TABLE>

<P>
The list of supported variables in <em class=file>DART/assimilation_code/modules/observations/obs_kind_mod.f90</em>
is created by <em class=program>preprocess</em> using the entries in 
<em class=file>input.nml</em>[<em class=code>&amp;preprocess_nml, &amp;obs_kind_nml</em>], 
<em class=file>DEFAULT_obs_kin_mod.F90</em> and
<em class=file>obs_def_ocean_mod.f90</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br />
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a model state, <em class=code>model_interpolate</em> returns the value of 
the desired observation type (which could be a state variable) that would be 
observed at the desired location. The interpolation method is either
completely specified by the model, or uses some standard 2D or 3D scalar
interpolation routines.
Put another way, <em class=code>model_interpolate</em> will apply the forward
operator <strong>H</strong> to the model state to create an observation at the desired 
location.
<br />
<br />
If the interpolation is valid, <em class=code>istatus = 0</em>. 
In the case where the observation operator is not defined at the given 
location (e.g. the observation is below the lowest model level, above the top
level, or 'dry'), interp_val is returned as 0.0 and istatus = 1. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which type of observation is desired.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.
       <br />success == 0, failure == anything else</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br />
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_model_time_step</em>
returns the forecast length to be used as the "model base time step" in the filter.
This is the minimum amount of time the model can be advanced by 
<em class=program>filter</em>.  
<em class="strong">This is also the assimilation window</em>. 
All observations within (+/-) one half of the forecast
length are used for the assimilation.
In the <em class=program>POP</em> case, this is set from 
the namelist values for <em class=file>input.nml</em><em
class=code>&amp;model_nml:assimilation_period_days, assimilation_period_seconds</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Smallest time step of model.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br />
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>static_init_model</em>
is called for runtime initialization of the model. 
The namelists are read to determine runtime configuration of the model, 
the grid coordinates, etc. There are no input arguments and no return values. 
The routine sets module-local private attributes that can then be queried by the
public interface routines.
<br />
<br />
See the POP documentation for all namelists in <em class=file>pop_in</em>&nbsp;.
Be aware that DART reads the POP <em class=code>&amp;grid_nml</em> namelist
to get the filenames for the horizontal and vertical grid information as well
as the topography information.
<br />
<br />
The namelists (all mandatory) are:<br />
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml</em>,<br />
<em class=file>pop_in</em><em class=code>&amp;time_manager_nml</em>,<br />
<em class=file>pop_in</em><em class=code>&amp;io_nml</em>,<br />
<em class=file>pop_in</em><em class=code>&amp;init_ts_nml</em>,<br />
<em class=file>pop_in</em><em class=code>&amp;restart_nml</em>,<br />
<em class=file>pop_in</em><em class=code>&amp;domain_nml</em>, and<br />
<em class=file>pop_in</em><em class=code>&amp;grid_nml</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br />
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>end_model</em>
is used to clean up storage for the model, etc. 
when the model is no longer needed. There are no arguments and no return values.
The grid variables are deallocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br />
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_time</em>
returns the time at which the model will start if no input initial conditions are
to be used. This is frequently used to spin-up models from rest, but is not
meaningfully supported for the POP model.  
The only time this routine would get called is if the 
<em class=file>input.nml</em><em class=code>&amp;perfect_model_obs_nml:start_from_restart</em> is .false., which is
not supported in the POP model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>the starting time for the model if no initial conditions are to be supplied.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br />
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_conditions</em>
returns default initial conditions for model; generally used for spinning up
initial model states. For the POP model it is just a stub because 
the initial state is always provided by the input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial conditions for state vector.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_atts</em>
writes model-specific attributes to an opened netCDF file:
In the POP case, this includes information like the 
coordinate variables (the grid arrays: ULON, ULAT, TLON, TLAT, ZG, ZC, KMT, KMU), 
information from some of the namelists, and either the 1D state 
vector or the prognostic variables (SALT,TEMP,UVEL,VVEL,PSURF). 
All the required information (except for the netCDF file identifier) 
is obtained from the scope of the <em class=program>model_mod</em> module.
Both the <em class=file>input.nml</em> and <em class=file>pop_in</em> files
are preserved in the netCDF file as variables <em class=code>inputnml</em> and
<em class=code>pop_in</em>, respectively.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

<P>
<em class=code>nc_write_model_atts</em>
is responsible for the model-specific attributes in the following DART-output netCDF files:
<em class=file>true_state.nc</em>, 
<em class=file>preassim.nc</em>, and 
<em class=file>analysis.nc</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
integer                            :: <em class=code>ierr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_vars</em>
writes a copy of the state variables to a NetCDF file. Multiple copies of the
state for a given time are supported, allowing, for instance, a single file to
include multiple ensemble estimates of the state. Whether the state vector is 
parsed into prognostic variables (SALT, TEMP, UVEL, VVEL, PSURF) or simply written 
as a 1D array is controlled by 
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml:output_state_vector</em>.
If <em class=code>output_state_vector&nbsp;=&nbsp;.true.</em> the state vector is 
written as a 1D array (the simplest case, but hard to explore with the diagnostics).
If <em class=code>output_state_vector&nbsp;=&nbsp;.false.</em> the state vector is 
parsed into prognostic variables before being written.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_copies"></A>
<br />
<div class=routine>
<em class=call>call pert_model_copies(state_ens_handle, ens_size, pert_amp, interf_provided)</em>
<pre>
type(ensemble_type), intent(inout) :: state_ens_handle
integer,             intent(in)    :: ens_size
real(r8),            intent(in)    :: pert_amp
logical,             intent(out)   :: interf_provided
</pre>
</div>

<div class=indent1> <!-- Description -->
<P>
<strong>This routine does not work with POP.</strong>
Given a handle to an ensemble of model states, <em class=code>pert_model_copies</em> produces an 
ensemble of perturbed model states. This is used to generate ensemble initial conditions 
perturbed around some control trajectory state when one is preparing to 
spin-up ensembles.  Since the DART state vector for the POP model 
contains both 'wet' and 'dry' cells, it is imperative to provide an 
interface to perturb <strong>just</strong> the wet cells 
(<em class=code>interf_provided == .true.</em>).
<br />
<br />
The magnitude of the perturbation is wholly determined by 
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml:model_perturbation_amplitude</em>
and <strong>utterly, completely fails</strong>.
<br />
<br />
A more robust perturbation mechanism is needed. 
Until then, avoid using this routine by using your own ensemble of initial conditions. 
This is determined by setting
<em class=file>input.nml</em><em class=code>&amp;filter_nml:start_from_restart = .false.</em>
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state_ens_handle</em></TD>
    <TD>the handle to the ensemble of state vectors to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>ens_size</em></TD>
    <TD>The number of ensemble members desired.</TD></TR>

<TR><TD valign=top><em class=code>pert_amp</em></TD>
    <TD>not used, since we have no viable method for perturbing POP.</TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Because of the 'wet/dry' issue discussed above, this is always 
        <em class=code>.true.</em>, indicating a model-specific perturbation 
        is available.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../assimilation_code/location/threed_sphere/location_mod.html#get_close_maxdist_init">get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../assimilation_code/location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, obs, obs_kind, &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type),              intent(in ) :: <em class=code>gc</em>
type(location_type),               intent(in ) :: <em class=code>base_obs_loc</em>
integer,                           intent(in ) :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in ) :: <em class=code>obs</em>
integer,             dimension(:), intent(in ) :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer,             dimension(:), intent(out) :: <em class=code>close_ind</em>
real(r8), optional,  dimension(:), intent(out) :: <em class=optionalcode>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a DART location (referred to as "base") and a set of locations, and a
definition of 'close' - return a subset of locations that are 'close', as well
as their distances to the DART location and their indices. This routine intentionally
masks a routine of the same name in <em class=program>location_mod</em> because we
want to be able to discriminate against selecting 'dry land' locations.
<br />
<br />
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.  The list of locations
passed in via the <em class=code>obs</em> argument must be identical to
the list of <em class=code>obs</em> passed into the most recent call
to <em class=code>get_close_obs_init()</em>.  If the list of locations
of interest changes, <em class=code>get_close_obs_destroy()</em> must
be called and then the two initialization routines must be called
before using <em class=code>get_close_obs()</em> again.
<br />
<br />
For vertical distance computations, the general philosophy is to convert all
vertical coordinates to a common coordinate. This coordinate type is defined
in the namelist with the variable "vert_localization_coord".
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Structure to allow efficient identification of
        locations 'close' to a given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_loc</em></TD>
    <TD>Single given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_kind</em></TD>
    <TD>Kind of the single location.</TD></TR>
<TR><TD valign=top><em class=code>obs</em></TD>
    <TD>List of candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Kind associated with candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>num_close</em></TD>
    <TD>Number of locations close to the given location.</TD></TR>
<TR><TD valign=top><em class=code>close_ind</em></TD>
    <TD>Indices of those locations that are close.</TD></TR>
<TR><TD valign=top><em class=optionalcode>dist</em></TD>
    <TD>Distance between given location and the
        close ones identified in close_ind.</TD></TR>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->
<!-- @todo FIXME totally incomplete -->
<A NAME="query_vert_localization_coord"></A>
<br />
<div class=routine>
<em class=call>coordinate_system = query_vert_localization_coord( )</em>
<pre>
integer :: <em class=code>query_vert_localization_coord</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Defines the vertical coordinate system to be used by assim_tools_mod.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>coordinate_system</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->
<!-- @todo FIXME totally incomplete -->
<A NAME="vert_convert"></A>
<br />
<div class=routine>
<em class=call>call vert_convert(state_handle, location, obs_kind, istatus)</em>
<pre>
type(ensemble_type), intent(in)  :: <em class=code>state_handle</em>
type(location_type), intent(in)  :: <em class=code>location</em>
integer,             intent(in)  :: <em class=code>obs_kind</em>
integer,             intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This subroutine converts a given ob/state vertical coordinate to
the vertical localization coordinate type requested through the 
model_mod namelist.
POP has a default vertical coordinate system of 'height'. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state_handle</em></TD>
    <TD>The handle to the ensemble of model states.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>The 3D location and vertical coordinate system of interest.
        The <em class=code>location_ type</em> comes from
        <em class=file>DART/location/threed_sphere/location_mod.f90</em>.
        Note that the lat/lon are specified in degrees by the user but are converted
        to radians internally.</TD></TR>

<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Kind associated with candidate locations.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the conversion.
       <br />success == 0, failure == anything else</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->
<!-- @todo FIXME totally incomplete -->
<A NAME="read_model_time"></A>
<br />
<div class=routine>
<em class=call>model_time = read_model_time(filename)</em>
<pre>
character(len=*), intent(in) :: <em class=code>filename</em>
type(time_type) :: <em class=code>model_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Reads the valid time of the model state contained in <em class=code>filename</em>.
Since each model may store the time in their own manner, each model must supply their
own routine to read it.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename</em></TD>
    <TD>The name of the netCDF file containing the valid time of the model state.</TD></TR>

<TR><TD valign=top><em class=code>model_time</em></TD>
    <TD>The time - in DART's own derived type (seconds and days since 1601-01-01 00:00:00)</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->
<A NAME="write_model_time"></A>
<br />
<div class=routine>
<em class=call>call write_model_time(ncid, dart_time)</em>
<pre>
integer,         intent(in) :: <em class=code>ncid</em>
type(time_type), intent(in) :: <em class=code>dart_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Writes the time to a netCDF file. For POP, this is actually a 'pass-through' to a routine of the same name in 
<a href='../../assimilation_code/modules/io/dart_time_io_mod.f90'>io/dart_time_io_mod.f90</a>  
which will write variables <em class=code>dart_days</em> and
<em class=code>dart_seconds</em> to the netCDF file if they do 
not already exist.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncid</em></TD>
    <TD>The netCDF ID of the file to receive the model time.</TD></TR>

<TR><TD valign=top><em class=code>dart_time</em></TD>
    <TD>The time - in DART's own derived type (seconds and days since 1601-01-01 00:00:00)</TD></TR>

</TABLE>

</div>
<br />

<!--==================================================================-->
<H3 class=indent1>Optional Public Interface Routines</H3>
<!--==================================================================-->


<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_gridsize"></A>
<br />
<div class="routine">
<em class=call>call get_gridsize( num_x, num_y, num_z )</em>
<pre>
integer, intent(out) :: <em class=code>num_x, num_y, num_z</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_gridsize</em>
returns the dimensions of the compute domain.
The horizontal gridsize is determined from <em class=file>pop.r.nc</em>.
The values of the horizontal grid cells is determined from the binary file
specified in the
<em class=file>pop_in</em><em class=routine>&amp;grid_nml:horiz_grid_file</em> setting.
<em class=file>pop_in</em><em class=routine>&amp;grid_nml:vert_grid_file</em> specifies
the name of the ASCII file containing the number and values of the vertical levels.
The actual values (not just the size) is needed by <em class=routine>get_state_meta_data()</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>num_x</em></TD>
    <TD>The number of longitudinal gridpoints.</TD></TR>

<TR><TD valign=top><em class=code>num_y</em></TD>
    <TD>The number of latitudinal gridpoints.</TD></TR>

<TR><TD valign=top><em class=code>num_z</em></TD>
    <TD>The number of vertical gridpoints.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="restart_file_to_sv"></A>
<br />
<div class="routine">
<em class=call>call restart_file_to_sv(filename, state_vector, model_time)</em>
<pre>
character(len=*),       intent(in)    :: <em class=code>filename</em>
real(r8), dimension(:), intent(inout) :: <em class=code>state_vector</em>
type(time_type),        intent(out)   :: <em class=code>model_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   <em class=code>restart_file_to_sv</em>
   Reads the list of variables specified in
   <em class=file>input.nml</em><em class=routine>&amp:model_nml:model_state_variables</em> 
   from a POP netCDF format restart file and packs them into a DART state 
   vector.  The DART vector is simply a 1D vector that includes all the 
   'dry' cells as well as the 'wet' ones.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename</em></TD>
    <TD>The name of the netCDF format POP restart file.</TD></TR>

<TR><TD valign=top><em class=code>state_vector</em></TD>
    <TD>The 1D array to be used by DART.</TD></TR>

<TR><TD valign=top><em class=code>model_time</em></TD>
    <TD>the 1D array containing the concatenated POP variables.
    To save storage, it is possible to modify the definition of 
    <em class=code>r8</em> in <em class=file>DART/common/types_mod.f90</em> 
    to be the same as that of <em class=code>r4</em>.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="sv_to_restart_file"></A>
<br />
<div class="routine">
<em class=call>call sv_to_restart_file(state_vector, filename, statedate)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>state_vector</em>
character(len=*),       intent(in) :: <em class=code>filename</em>
type(time_type),        intent(in) :: <em class=code>statedate</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>sv_to_restart_file</em>
updates the  variables specified in 
<em class=file>input.nml</em><em class=routine>&amp:model_nml:model_state_variables</em> 
in the POP netCDF-format restart file with values from the DART 
vector <em class=code>state_vector</em>. The time in the
file must match the <em class=code>statedate</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state_vector</em></TD>
    <TD>the 1D array containing the DART state vector.</TD></TR>

<TR><TD valign=top><em class=code>filename</em></TD>
    <TD>the netCDF-format POP restart file to be updated.
</TD></TR>

<TR><TD valign=top><em class=code>statedate</em></TD>
    <TD>the 'valid_time' of the DART state vector.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_pop_restart_filename"></A>
<br />
<div class="routine">
<em class=call>call get_pop_restart_filename( filename )</em>
<pre>
character(len=*), intent(out) :: <em class=code>filename</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_pop_restart_filename</em>
is actually a 'pass-through' to a routine of the same name in 
<em class=file>dart_pop_mod.f90</em>, since the filename is in
module storage in <em class=program>dart_pop_mod</em>.

</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>The name of the POP restart file. Hardcoded to <em class=file>pop.r.nc</em>&nbsp;.
    This simplifies the scripting portions - dereference the pointer files, make a link
    to <em class=file>pop.r.nc</em> and you're done.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="test_interpolation"></A>
<br />
<div class="routine">
<em class=call>call test_interpolation( test_casenum )</em>
<pre>
integer, intent(in) :: <em class=code>test_casenum</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>test_interpolation</em>
is a rigorous test of the interpolation routine and relies completely
on data files that are not normally distributed with DART. This routine
is only used by <em class=file>test_dipole_interp.f90</em> and is not 
normally part of the user-callable routines.
</P>

</div>
<br />

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>

<TABLE border=0 width=100%>
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>pop_in</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>pop.r.nc</TD>
    <TD>provides grid dimensions and 'valid_time' of the model state</TD></TR>
<TR><TD><em class=code>&amp;grid_nml</em> "horiz_grid_file"</TD>
    <TD>contains the values of the horizontal grid</TD></TR>
<TR><TD><em class=code>&amp;grid_nml</em> "vert_grid_file"</TD>
    <TD>contains the number and values of the vertical levels</TD></TR>
<TR><TD>true_state.nc</TD>
    <TD>the time-history of the "true" model state from an OSSE</TD></TR>
<TR><TD>preassim.nc</TD>
    <TD>the time-history of the model state before assimilation</TD></TR>
<TR><TD>analysis.nc&nbsp;</TD>
    <TD>the time-history of the model state after assimilation</TD></TR>
<TR><TD>dart_log.out [default name]</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml [default name]</TD>
    <TD>the record of all the namelists actually USED - 
        contains the default values</TD></TR>
</TABLE>
<br />

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ul>
<li> none </li>
</ul>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH width="50%">Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>update_reg_list</TD>
    <!-- message --><TD VALIGN=top>max_reg_list_num&nbsp;(##)&nbsp;is&nbsp;too&nbsp;small&nbsp;...&nbsp;increase
values.</TD>
    <!-- comment --><TD VALIGN=top>The max_reg_list_num controls the size of temporary 
    storage used for initializing the regular grid. Four arrays of size 
    num_reg_x*num_reg_y*max_reg_list_num are needed. The initialization
    fails and returns an error if max_reg_list_num is too small. A value of
    30 is sufficient for the x3 POP grid with 180 regular lon and lat boxes 
    and a value of 80 is sufficient for for the x1 grid. Look at the output
    from <em class=program>init_dipole_interp()</em> for values for new grids.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>restart_file_to_sv</TD>
    <!-- message --><TD VALIGN=top>cannot open file "xxxx" for reading</TD>
    <!-- comment --><TD VALIGN=top>The POP restart file "xxxx" does not exist.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>restart_file_to_sv</TD>
    <!-- message --><TD VALIGN=top>'WARNING!!!   year 0 not supported; setting to year 1</TD>
    <!-- comment --><TD VALIGN=top>Some POP restart files have year 0 ... which is not
    supported in a Gregorian calendar. Our intent here is to do data assimilation,
    normally 'real' observations have 'real' dates.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>sv_to_restart_file</TD>
    <!-- message --><TD VALIGN=top>current time /= model time. FATAL error.</TD>
    <!-- comment --><TD VALIGN=top>The DART time does not match the time of the POP restart file.
    This message is preceeded by several lines indicating the expected times of both DART and POP.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>test_interpolation</TD>
    <!-- message --><TD VALIGN=top>mismatch nx,nx_temp ##,## or ny,ny_temp ##,##</TD>
    <!-- comment --><TD VALIGN=top>The file sizes do not match the expected sizes for the
    interpolation test case being performed.</TD>
</TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<P>
<em class=file>dart_pop_mod</em>:<em class=code>set_model_time_step()</em> 
must ensure the forecast length is a multiple of the ocean model 
dynamical timestep declared by ????
<br />
<br />
Provide a better mechanism for generating a set of perturbed initial 
conditions - <em class=code>pert_model_copies()</em> 
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright UCAR. This open source software is provided
by UCAR, "as is", without charge, subject to all terms of use at
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision: 11612 $ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL: https://svn-dares-dart.cgd.ucar.edu/DART/branches/rma_trunk/models/POP/model_mod.html $ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date: 2017-05-08 16:18:42 -0600 (Mon, 08 May 2017) $ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
